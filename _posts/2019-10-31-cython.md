---
layout: post
title: Cython
categories: typed python
description: 各种方式给 python 加类型(加速)
keywords: cython
---  

python 的灵活大家都懂的，动态类型，所以 IDE 在你编写函数的时候没有办法给出很多的自动补全提示，加上了 type hint 之后，感觉好多了。但是 type hint 只是 hint， 毕竟没有真正的静态类型，那么使用 Cython 可以实现这个哦。

这篇 Post 其实主要还是翻译官方的 Tutorials.

## Cython 基础

Cython 的本质就是带有 C 数据类型的 Python。

## Hello world

首先写一个 cython 插件，这里我们使用 `pyx` 文件后缀，意义应该是 Python extension.

```python
#hello.pyx
print("hello world!")
```
然后写一个 `setup.py` 去准备把插件编译成为 python 可用的东西。

```python
#setup.py
from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules = cythonize("helloworld.pyx")
)
```

编译，这是是常规的 Python steup 方法啦。就是 steup.py 里面的一个命令， buiold_ext 就和 bdist_wheel 没有什么两样，`--inplace` 使得它的编译目录是这个文件夹。这个过程中生成了 C 代码 `helloworld.c` 和动态库 `.so`.

```bash
python setup.py build_ext --inplace
```

然后试图去 import 这个模块 helloworld 的时候，就会打印出 `Hello world!` 了。还好？

## pyximport 

像上面这样，我们写的 cython 扩展里面没有依赖其他的 C 库，也不需要设定什么编译选项，那么可以使用更加便捷的方法来把编译的过程完成。那就是 Pyximport. 使用了这个之后 import `pyx` 模块的时候就可以自动编译了。

不过值得注意的是因为 python2 python3 的问题也影响到了 cython, 所以 cython 也需要设置 python2 或者 Python3，

```text
/workspace/virtualenvs/scientific/local/lib/python3.5/site-packages/Cython/Compiler/Main.py:369: FutureWarning: Cython directive 'language_level' not set, using 2 for now (Py2). This will change in a later release! File: /workspace/projects/playground/cython/hello_word/helloworld.pyx
  tree = Parsing.p_module(s, pxd, full_module_name)
hello world
```

我们暂且不管这个，总之是用办法设置这个的，那就是 `pyximport.install(language_lebel=3)`.

另外一个特征是，你甚至可以用它来 import 普通的 python 模块哦。这样你就是在运行 cython 了，包括标准库和第三方库。但是如果这个库 cython 不能支持，它又会回落到 python 上。只需要打开这个选项，而且默认是开启的。

```python
pyximport.install(pyimport=True)
```

## Fibonacci 函数的例子

```python
def fib(n):
    """Print the Fibonacci series up to n."""
    a, b = 0, 1
    while b < n:
        print(b, end=' ')
        a, b = b, a + b

    print()
```

然后编写 `setup.py`, 不过值得注意的是，如果你的 `pyx` 文件使用的是 Python3 的语法，直接编译会通不过，你需要设置 `language_level=3`, 这个是参数可以传给 `cythonize`。

```python
# setup.py
from distutils.core import setup
from Cython.Build import cythonize

setup(
    ext_modules=cythonize("fib.pyx", language_level=3),
)
```

## 素数例子，加上 ctype

```python
# primes.pyx
def primes(int nb_primes):
    cdef int n, i, len_p
    cdef int p[1000]
    if nb_primes > 1000:
        nb_primes = 1000

    len_p = 0  # The current number of elements in p.
    n = 2
    while len_p < nb_primes:
        # Is n prime?
        for i in p[:len_p]:
            if n % i == 0:
                break

        # If no break occurred in the loop, we have a prime.
        else:
            p[len_p] = n
            len_p += 1
        n += 1

    # Let's return the result in a python list:
    result_as_list  = [prime for prime in p[:len_p]]
    return result_as_list
```

需要注意的是，循环和迭代 C 数组的时候必须要注意边界，以及最后需要把结果 copy 回来。

注： `pyx` 文件里面可以使用 cdef 定义 C 类型的东西，但是如果要操作多为数组，你还是去用 numpy 的 C API 吧。

那么这个下次说啦。
